package network

import (
	"fmt"

	ciliumv2 "github.com/cilium/cilium/pkg/k8s/apis/cilium.io/v2"
	"github.com/cilium/cilium/pkg/labels"
	ciliumapi "github.com/cilium/cilium/pkg/policy/api"
	log "github.com/rs/zerolog/log"
	"github.com/xentra-ai/advisor/pkg/api"
	networkingv1 "k8s.io/api/networking/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
)

// CiliumPolicyGenerator generates Cilium NetworkPolicy resources
type CiliumPolicyGenerator struct{}

// NewCiliumPolicyGenerator creates a new generator for Cilium NetworkPolicy resources
func NewCiliumPolicyGenerator() *CiliumPolicyGenerator {
	return &CiliumPolicyGenerator{}
}

// GetType returns the policy type
func (g *CiliumPolicyGenerator) GetType() PolicyType {
	return CiliumPolicy
}

// Generate creates a CiliumNetworkPolicy for the specified pod
//
// This uses the same corrected traffic processing logic as the standard policy generator
// but leverages Cilium's enhanced features like:
// - EndpointSelector with more flexible label matching
// - FromCIDR for external IP blocks
// - ToPorts with protocol specification
// - Better integration with service discovery
func (g *CiliumPolicyGenerator) Generate(podName string, podTraffic []api.PodTraffic, podDetail *api.PodDetail) (interface{}, error) {
	log.Info().Msgf("Generating Cilium network policy for pod %s", podName)

	if podDetail == nil {
		return nil, fmt.Errorf("pod detail is nil for pod %s", podName)
	}

	if len(podTraffic) == 0 {
		// If there's no traffic, generate a default-deny policy
		log.Warn().Msgf("No traffic data available for pod %s. Generating a default-deny Cilium policy.", podName)
		return g.generateDefaultDenyPolicy(podDetail), nil
	}

	// Process traffic using the same corrected logic as standard policy generator
	ingressRules, egressRules := g.processTrafficRules(podTraffic, podDetail)

	// Create the CiliumNetworkPolicy object
	policy := &ciliumv2.CiliumNetworkPolicy{
		TypeMeta: CreateTypeMeta("CiliumNetworkPolicy", "cilium.io/v2"),
		ObjectMeta: CreateObjectMeta(
			GetPolicyName(podDetail.Name, "cilium-policy"),
			podDetail.Namespace,
			CreateStandardLabels(podDetail.Name, "cilium-policy"),
		),
		Spec: &ciliumapi.Rule{
			EndpointSelector: g.createEndpointSelector(podDetail.Pod.Labels),
			Description:      fmt.Sprintf("Cilium network policy for pod %s generated by xentra-advisor", podDetail.Name),
		},
	}

	// Add ingress rules if any
	if len(ingressRules) > 0 {
		policy.Spec.Ingress = g.transformToCiliumIngressRules(ingressRules)
		log.Debug().Msgf("Added %d ingress rules to Cilium policy", len(policy.Spec.Ingress))
	}

	// Add egress rules if any
	if len(egressRules) > 0 {
		policy.Spec.Egress = g.transformToCiliumEgressRules(egressRules)
		log.Debug().Msgf("Added %d egress rules to Cilium policy", len(policy.Spec.Egress))
	}

	// If no rules were added, make it default deny
	if len(policy.Spec.Ingress) == 0 && len(policy.Spec.Egress) == 0 {
		log.Warn().Msgf("No valid ingress or egress rules generated for pod %s. Applying default-deny.", podName)
		return g.generateDefaultDenyPolicy(podDetail), nil
	}

	return policy, nil
}

// generateDefaultDenyPolicy creates a Cilium policy that denies all traffic
func (g *CiliumPolicyGenerator) generateDefaultDenyPolicy(podDetail *api.PodDetail) *ciliumv2.CiliumNetworkPolicy {
	// Create bool pointers for DefaultDenyConfig
	truePtr := true

	return &ciliumv2.CiliumNetworkPolicy{
		TypeMeta: CreateTypeMeta("CiliumNetworkPolicy", "cilium.io/v2"),
		ObjectMeta: CreateObjectMeta(
			GetPolicyName(podDetail.Name, "cilium-policy-deny-all"),
			podDetail.Namespace,
			CreateStandardLabels(podDetail.Name, "cilium-policy-deny-all"),
		),
		Spec: &ciliumapi.Rule{
			EndpointSelector: g.createEndpointSelector(podDetail.Pod.Labels),
			Description:      fmt.Sprintf("Default-deny Cilium network policy for pod %s", podDetail.Name),
			// Cilium default-deny behavior: empty ingress/egress rules with EnableDefaultDeny
			EnableDefaultDeny: ciliumapi.DefaultDenyConfig{
				Ingress: &truePtr,
				Egress:  &truePtr,
			},
		},
	}
}

// processTrafficRules groups traffic rules by direction using the corrected logic
func (g *CiliumPolicyGenerator) processTrafficRules(podTraffic []api.PodTraffic, podDetail *api.PodDetail) ([]NetworkPolicyRule, []NetworkPolicyRule) {
	var ingressRules, egressRules []NetworkPolicyRule

	for _, traffic := range podTraffic {
		var portInt int
		var err error
		var peer string
		var port intstr.IntOrString
		var protocolStr string

		if IsIngressTraffic(traffic, podDetail) {
			// For INGRESS traffic: External peer -> Our Pod
			// - Peer is the source sending to us (traffic.DstIP - the external entity)
			// - Port is the port on our pod receiving the traffic (traffic.SrcPodPort)
			peer = traffic.DstIP

			// Skip if peer is empty or same as pod's own IP (self-traffic)
			if peer == "" {
				log.Debug().Msgf("Skipping ingress traffic with empty peer IP")
				continue
			}
			if peer == podDetail.PodIP {
				log.Debug().Msgf("Skipping ingress self-traffic (peer %s == pod IP %s)", peer, podDetail.PodIP)
				continue
			}

			portInt, err = parsePort(traffic.SrcPodPort)
			if err != nil {
				log.Warn().Err(err).Msgf("Skipping ingress traffic record due to invalid pod port: %s", traffic.SrcPodPort)
				continue
			}
			port = intstr.FromInt(portInt)
			protocolStr = string(traffic.Protocol)

			log.Debug().Msgf("Processing CILIUM INGRESS: allowing peer %s to reach our pod port %d (%s)", peer, portInt, protocolStr)
			ingressRules = g.addOrUpdateRule(ingressRules, peer, port, protocolStr)

		} else if IsEgressTraffic(traffic, podDetail) {
			// For EGRESS traffic: Our Pod -> External destination
			// - Peer is the destination (traffic.DstIP - where our pod is connecting to)
			// - Port is the destination port (traffic.DstPort - the port on the target service/pod)
			peer = traffic.DstIP

			// Skip if peer is empty or same as pod's own IP (self-traffic)
			if peer == "" {
				log.Debug().Msgf("Skipping egress traffic with empty peer IP")
				continue
			}
			if peer == podDetail.PodIP {
				log.Debug().Msgf("Skipping egress self-traffic (peer %s == pod IP %s)", peer, podDetail.PodIP)
				continue
			}

			portInt, err = parsePort(traffic.DstPort)
			if err != nil {
				log.Warn().Err(err).Msgf("Skipping egress traffic record due to invalid destination port: %s", traffic.DstPort)
				continue
			}
			port = intstr.FromInt(portInt)
			protocolStr = string(traffic.Protocol)

			log.Debug().Msgf("Processing CILIUM EGRESS: allowing our pod to reach peer %s on port %d (%s)", peer, portInt, protocolStr)
			egressRules = g.addOrUpdateRule(egressRules, peer, port, protocolStr)
		} else {
			log.Debug().Msgf("Skipping traffic record with unknown type: %s", traffic.TrafficType)
		}
	}

	log.Info().Msgf("Generated %d ingress rules and %d egress rules for Cilium policy of pod %s",
		len(ingressRules), len(egressRules), podDetail.Name)

	return ingressRules, egressRules
}

// addOrUpdateRule adds a port to an existing rule for a peer or creates a new rule
func (g *CiliumPolicyGenerator) addOrUpdateRule(rules []NetworkPolicyRule, peer string, port intstr.IntOrString, protocolStr string) []NetworkPolicyRule {
	protocol := protocolPtr(protocolStr)

	for i := range rules {
		if rules[i].PeerIP == peer {
			// Found rule for the peer, check if port/protocol combo exists
			portExists := false
			for _, existingPort := range rules[i].Ports {
				if existingPort.Port != nil && existingPort.Port.String() == port.String() &&
					existingPort.Protocol != nil && *existingPort.Protocol == *protocol {
					portExists = true
					break
				}
			}
			if !portExists {
				// Add port to existing rule
				rules[i].Ports = append(rules[i].Ports, networkingv1.NetworkPolicyPort{
					Port:     &port,
					Protocol: protocol,
				})
			}
			return rules // Rule updated or port already existed
		}
	}

	// No rule found for this peer, create a new one
	newRule := NetworkPolicyRule{
		PeerIP: peer,
		Ports: []networkingv1.NetworkPolicyPort{
			{
				Port:     &port,
				Protocol: protocol,
			},
		},
	}
	return append(rules, newRule)
}

// createEndpointSelector creates a Cilium EndpointSelector from pod labels
func (g *CiliumPolicyGenerator) createEndpointSelector(podLabels map[string]string) ciliumapi.EndpointSelector {
	if len(podLabels) == 0 {
		log.Warn().Msg("Pod has no labels, using empty EndpointSelector")
		return ciliumapi.EndpointSelector{}
	}

	labelArray := make(labels.LabelArray, 0, len(podLabels))
	for key, value := range podLabels {
		labelArray = append(labelArray, labels.NewLabel(key, value, labels.LabelSourceK8s))
	}

	return ciliumapi.NewESFromLabels(labelArray...)
}

// transformToCiliumIngressRules converts our internal rules to Cilium IngressRule
func (g *CiliumPolicyGenerator) transformToCiliumIngressRules(rules []NetworkPolicyRule) []ciliumapi.IngressRule {
	var ingressRules []ciliumapi.IngressRule

	// Group rules by peer IP
	peerRules := make(map[string][]networkingv1.NetworkPolicyPort)
	for _, rule := range rules {
		peerRules[rule.PeerIP] = append(peerRules[rule.PeerIP], rule.Ports...)
	}

	// Create ingress rules
	for peerIP, ports := range peerRules {
		ingressRule := g.createCiliumIngressRuleForPeer(peerIP, ports)
		if ingressRule != nil {
			ingressRules = append(ingressRules, *ingressRule)
		}
	}

	return ingressRules
}

// transformToCiliumEgressRules converts our internal rules to Cilium EgressRule
func (g *CiliumPolicyGenerator) transformToCiliumEgressRules(rules []NetworkPolicyRule) []ciliumapi.EgressRule {
	var egressRules []ciliumapi.EgressRule

	// Group rules by peer IP
	peerRules := make(map[string][]networkingv1.NetworkPolicyPort)
	for _, rule := range rules {
		peerRules[rule.PeerIP] = append(peerRules[rule.PeerIP], rule.Ports...)
	}

	// Create egress rules
	for peerIP, ports := range peerRules {
		egressRule := g.createCiliumEgressRuleForPeer(peerIP, ports)
		if egressRule != nil {
			egressRules = append(egressRules, *egressRule)
		}
	}

	return egressRules
}

// createCiliumIngressRuleForPeer creates a Cilium ingress rule for a specific peer
func (g *CiliumPolicyGenerator) createCiliumIngressRuleForPeer(peerIP string, ports []networkingv1.NetworkPolicyPort) *ciliumapi.IngressRule {
	log.Debug().Msgf("Creating Cilium ingress rule for peer IP: %s", peerIP)

	// Try to resolve peer information
	fromEndpoints, fromCIDR := g.resolvePeerForCilium(peerIP)

	var ingressRule ciliumapi.IngressRule

	// Set the peer selector
	if len(fromEndpoints) > 0 {
		ingressRule.FromEndpoints = fromEndpoints
		log.Debug().Msgf("Using FromEndpoints for peer %s", peerIP)
	} else if len(fromCIDR) > 0 {
		ingressRule.FromCIDR = fromCIDR
		log.Debug().Msgf("Using FromCIDR for peer %s", peerIP)
	} else {
		log.Warn().Msgf("Could not resolve peer %s, skipping rule", peerIP)
		return nil
	}

	// Convert ports to Cilium PortRules
	ingressRule.ToPorts = g.convertPortsToCiliumPortRules(ports)

	return &ingressRule
}

// createCiliumEgressRuleForPeer creates a Cilium egress rule for a specific peer
func (g *CiliumPolicyGenerator) createCiliumEgressRuleForPeer(peerIP string, ports []networkingv1.NetworkPolicyPort) *ciliumapi.EgressRule {
	log.Debug().Msgf("Creating Cilium egress rule for peer IP: %s", peerIP)

	// Try to resolve peer information
	toEndpoints, toCIDR := g.resolvePeerForCilium(peerIP)

	var egressRule ciliumapi.EgressRule

	// Set the peer selector
	if len(toEndpoints) > 0 {
		egressRule.ToEndpoints = toEndpoints
		log.Debug().Msgf("Using ToEndpoints for peer %s", peerIP)
	} else if len(toCIDR) > 0 {
		egressRule.ToCIDR = toCIDR
		log.Debug().Msgf("Using ToCIDR for peer %s", peerIP)
	} else {
		log.Warn().Msgf("Could not resolve peer %s, skipping rule", peerIP)
		return nil
	}

	// Convert ports to Cilium PortRules
	egressRule.ToPorts = g.convertPortsToCiliumPortRules(ports)

	return &egressRule
}

// resolvePeerForCilium resolves peer IP to either EndpointSelector or CIDR
func (g *CiliumPolicyGenerator) resolvePeerForCilium(peerIP string) ([]ciliumapi.EndpointSelector, ciliumapi.CIDRSlice) {
	// Try to get Service info first
	svcSpec, err := api.GetSvcSpec(peerIP)
	if err == nil && svcSpec != nil && len(svcSpec.Service.Spec.Selector) > 0 {
		log.Debug().Msgf("Found service %s/%s with selector %v for IP %s",
			svcSpec.SvcNamespace, svcSpec.SvcName, svcSpec.Service.Spec.Selector, peerIP)

		// Create EndpointSelector from service labels
		selector := g.createEndpointSelector(svcSpec.Service.Spec.Selector)
		return []ciliumapi.EndpointSelector{selector}, nil
	}

	// Try to get Pod info
	podSpec, err := api.GetPodSpec(peerIP)
	if err == nil && podSpec != nil && len(podSpec.Pod.Labels) > 0 {
		log.Debug().Msgf("Found pod %s/%s with labels %v for IP %s",
			podSpec.Namespace, podSpec.Name, podSpec.Pod.Labels, peerIP)

		// Create EndpointSelector from pod labels
		selector := g.createEndpointSelector(podSpec.Pod.Labels)
		return []ciliumapi.EndpointSelector{selector}, nil
	}

	// Fall back to CIDR for external IPs or unresolvable cluster IPs
	log.Debug().Msgf("Using CIDR for peer %s", peerIP)
	cidr := ciliumapi.CIDR(fmt.Sprintf("%s/32", peerIP))
	return nil, ciliumapi.CIDRSlice{cidr}
}

// convertPortsToCiliumPortRules converts standard ports to Cilium PortRules
func (g *CiliumPolicyGenerator) convertPortsToCiliumPortRules(ports []networkingv1.NetworkPolicyPort) ciliumapi.PortRules {
	portRules := make(ciliumapi.PortRules, 0, len(ports))

	for _, port := range ports {
		if port.Port == nil || port.Protocol == nil {
			log.Warn().Msg("Skipping port with nil port or protocol")
			continue
		}

		portRule := ciliumapi.PortRule{
			Ports: []ciliumapi.PortProtocol{
				{
					Port:     port.Port.String(),
					Protocol: ciliumapi.L4Proto(string(*port.Protocol)),
				},
			},
		}
		portRules = append(portRules, portRule)
	}

	return portRules
}
